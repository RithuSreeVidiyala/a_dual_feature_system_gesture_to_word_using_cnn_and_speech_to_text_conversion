// WebAudioRecorder Module
(function(window) {
    // Utility Function: Deep Merge Objects
    const mergeObjects = function() {
        const target = arguments[0];
        const sources = [].slice.call(arguments, 1);
        
        for(let i = 0; i < sources.length; ++i) {
            const source = sources[i];
            for(let key in source) {
                const value = source[key];
                target[key] = (typeof value === "object") 
                    ? mergeObjects((typeof target[key] === "object" ? target[key] : {}), value)
                    : value;
            }
        }
        return target;
    };

    // Configuration Constants
    const WORKER_FILES = {
        wav: "WebAudioRecorderWav.min.js",
        ogg: "WebAudioRecorderOgg.min.js",
        mp3: "WebAudioRecorderMp3.min.js"
    };

    const DEFAULT_OPTIONS = {
        workerDir: "/",
        numChannels: 2,
        encoding: "wav",
        options: {
            timeLimit: 300,           // seconds
            encodeAfterRecord: false,
            progressInterval: 1000,   // milliseconds
            bufferSize: undefined,
            wav: { mimeType: "audio/wav" },
            ogg: { 
                mimeType: "audio/ogg",
                quality: 0.5 
            },
            mp3: { 
                mimeType: "audio/mpeg",
                bitRate: 160 
            }
        }
    };

    // WebAudioRecorder Class
    class WebAudioRecorder {
        constructor(sourceNode, config = {}) {
            // Initialize with defaults and custom config
            mergeObjects(this, DEFAULT_OPTIONS, config);
            
            // Audio Context Setup
            this.context = sourceNode.context;
            if(!this.context.createScriptProcessor) {
                this.context.createScriptProcessor = this.context.createJavaScriptNode;
            }
            
            // Audio Nodes
            this.input = this.context.createGain();
            sourceNode.connect(this.input);
            
            // Internal State
            this.buffer = [];
            this.initWorker();
        }

        // Recording State
        isRecording() {
            return this.processor != null;
        }

        // Configuration Methods
        setEncoding(encoding) {
            if(this.isRecording()) {
                this.error("setEncoding: cannot set encoding during recording");
            } else if(this.encoding !== encoding) {
                this.encoding = encoding;
                this.initWorker();
            }
        }

        setOptions(options) {
            if(this.isRecording()) {
                this.error("setOptions: cannot set options during recording");
            } else {
                mergeObjects(this.options, options);
                this.worker.postMessage({
                    command: "options",
                    options: this.options
                });
            }
        }

        // Recording Control
        startRecording() {
            if(this.isRecording()) {
                this.error("startRecording: previous recording is running");
                return;
            }

            const { numChannels, buffer, worker } = this;
            this.processor = this.context.createScriptProcessor(
                this.options.bufferSize,
                numChannels,
                numChannels
            );

            this.input.connect(this.processor);
            this.processor.connect(this.context.destination);
            
            this.processor.onaudioprocess = (e) => {
                for(let ch = 0; ch < numChannels; ++ch) {
                    buffer[ch] = e.inputBuffer.getChannelData(ch);
                }
                worker.postMessage({
                    command: "record",
                    buffer: buffer
                });
            };

            worker.postMessage({
                command: "start",
                bufferSize: this.processor.bufferSize
            });
            this.startTime = Date.now();
        }

        recordingTime() {
            return this.isRecording() ? (Date.now() - this.startTime) * 0.001 : null;
        }

        cancelRecording() {
            if(!this.isRecording()) {
                this.error("cancelRecording: no recording is running");
                return;
            }
            this.input.disconnect();
            this.processor.disconnect();
            delete this.processor;
            this.worker.postMessage({ command: "cancel" });
        }

        finishRecording() {
            if(!this.isRecording()) {
                this.error("finishRecording: no recording is running");
                return;
            }
            this.input.disconnect();
            this.processor.disconnect();
            delete this.processor;
            this.worker.postMessage({ command: "finish" });
        }

        cancelEncoding() {
            if(!this.options.encodeAfterRecord) {
                this.error("cancelEncoding: invalid method call");
            } else if(this.isRecording()) {
                this.error("cancelEncoding: recording is not finished");
            } else {
                this.onEncodingCanceled(this);
                this.initWorker();
            }
        }

        // Worker Management
        initWorker() {
            if(this.worker) {
                this.worker.terminate();
            }
            
            this.onEncoderLoading(this, this.encoding);
            this.worker = new Worker(this.workerDir + WORKER_FILES[this.encoding]);

            this.worker.onmessage = (e) => {
                switch(e.data.command) {
                    case "loaded":
                        this.onEncoderLoaded(this, this.encoding);
                        break;
                    case "timeout":
                        this.onTimeout(this);
                        break;
                    case "progress":
                        this.onEncodingProgress(this, e.data.progress);
                        break;
                    case "complete":
                        this.onComplete(this, e.data.blob);
                        break;
                    case "error":
                        this.error(e.data.message);
                        break;
                }
            };

            this.worker.postMessage({
                command: "init",
                config: {
                    sampleRate: this.context.sampleRate,
                    numChannels: this.numChannels
                },
                options: this.options
            });
        }

        // Event Handlers
        error(message) {
            this.onError(this, "WebAudioRecorder.min.js:" + message);
        }

        // Event Hooks (to be overridden)
        onEncoderLoading(recorder, encoding) {}
        onEncoderLoaded(recorder, encoding) {}
        onTimeout(recorder) {
            recorder.finishRecording();
        }
        onEncodingProgress(recorder, progress) {}
        onEncodingCanceled(recorder) {}
        onComplete(recorder, blob) {
            recorder.onError(recorder, "WebAudioRecorder.min.js: You must override .onComplete event");
        }
        onError(recorder, message) {
            console.log(message);
        }
    }

    // Export to window
    window.WebAudioRecorder = WebAudioRecorder;

})(window);