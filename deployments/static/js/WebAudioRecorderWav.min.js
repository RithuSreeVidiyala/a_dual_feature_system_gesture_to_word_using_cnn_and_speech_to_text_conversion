// WAV Audio Encoder Module
(function(self) {
    // Utility Functions
    const min = Math.min;
    const max = Math.max;
    
    // Write string to DataView
    const writeString = function(view, offset, string) {
        for(let i = 0; i < string.length; ++i) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    };

    // WAV Encoder Class
    class WavAudioEncoder {
        constructor(sampleRate, numChannels) {
            this.sampleRate = sampleRate;
            this.numChannels = numChannels;
            this.numSamples = 0;
            this.dataViews = [];
        }

        encode(buffers) {
            const len = buffers[0].length;
            const buffer = new DataView(new ArrayBuffer(len * this.numChannels * 2));
            let offset = 0;

            for(let i = 0; i < len; ++i) {
                for(let ch = 0; ch < this.numChannels; ++ch) {
                    const sample = buffers[ch][i] * 32767;
                    buffer.setInt16(offset, sample < 0 ? max(sample, -32768) : min(sample, 32767), true);
                    offset += 2;
                }
            }
            this.dataViews.push(buffer);
            this.numSamples += len;
        }

        finish(mimeType) {
            const dataSize = this.numChannels * this.numSamples * 2;
            const header = new DataView(new ArrayBuffer(44));
            
            // WAV Header
            writeString(header, 0, "RIFF");
            header.setUint32(4, 36 + dataSize, true);
            writeString(header, 8, "WAVE");
            writeString(header, 12, "fmt ");
            header.setUint32(16, 16, true);      // Subchunk1Size
            header.setUint16(20, 1, true);       // AudioFormat (PCM)
            header.setUint16(22, this.numChannels, true);
            header.setUint32(24, this.sampleRate, true);
            header.setUint32(28, this.sampleRate * 4, true);  // ByteRate
            header.setUint16(32, this.numChannels * 2, true); // BlockAlign
            header.setUint16(34, 16, true);      // BitsPerSample
            writeString(header, 36, "data");
            header.setUint32(40, dataSize, true);

            this.dataViews.unshift(header);
            const blob = new Blob(this.dataViews, { type: mimeType || "audio/wav" });
            this.cleanup();
            return blob;
        }

        cleanup() {
            delete this.dataViews;
        }

        cancel = this.cleanup;
    }

    // Global Variables
    let sampleRate = 44100;
    let numChannels = 2;
    let options;
    let maxBuffers;
    let encoder;
    let recBuffers;
    let bufferCount = 0;

    // Message Handlers
    const handlers = {
        error(message) {
            self.postMessage({ command: "error", message: "wav: " + message });
        },

        init(data) {
            sampleRate = data.config.sampleRate;
            numChannels = data.config.numChannels;
            options = data.options;
        },

        setOptions(data) {
            if(encoder || recBuffers) {
                this.error("cannot set options during recording");
            } else {
                options = data.options;
            }
        },

        start(bufferSize) {
            maxBuffers = Math.ceil(options.timeLimit * sampleRate / bufferSize);
            if(options.encodeAfterRecord) {
                recBuffers = [];
            } else {
                encoder = new WavAudioEncoder(sampleRate, numChannels);
            }
        },

        record(buffers) {
            if(bufferCount++ < maxBuffers) {
                if(encoder) {
                    encoder.encode(buffers);
                } else {
                    recBuffers.push(buffers);
                }
            } else {
                self.postMessage({ command: "timeout" });
            }
        },

        postProgress(progress) {
            self.postMessage({ command: "progress", progress });
        },

        finish() {
            if(recBuffers) {
                this.postProgress(0);
                encoder = new WavAudioEncoder(sampleRate, numChannels);
                let nextProgress = Date.now() + options.progressInterval;

                while(recBuffers.length > 0) {
                    encoder.encode(recBuffers.shift());
                    const now = Date.now();
                    if(now > nextProgress) {
                        this.postProgress((bufferCount - recBuffers.length) / bufferCount);
                        nextProgress = now + options.progressInterval;
                    }
                }
                this.postProgress(1);
            }
            self.postMessage({ 
                command: "complete", 
                blob: encoder.finish(options?.wav?.mimeType) 
            });
            this.cleanup();
        },

        cleanup() {
            encoder = recBuffers = undefined;
            bufferCount = 0;
        }
    };

    // Worker Message Listener
    self.onmessage = function(e) {
        const data = e.data;
        switch(data.command) {
            case "init": handlers.init(data); break;
            case "options": handlers.setOptions(data); break;
            case "start": handlers.start(data.bufferSize); break;
            case "record": handlers.record(data.buffer); break;
            case "finish": handlers.finish(); break;
            case "cancel": handlers.cleanup(); break;
        }
    };

    // Initialization Complete Signal
    self.postMessage({ command: "loaded" });

})(self);